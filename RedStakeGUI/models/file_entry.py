import logging

import ttkbootstrap as ttk

from RedStakeGUI.constants import ACCESS_DATABASE
from RedStakeGUI.models.access_database import AccessDB, Table
from RedStakeGUI.models.data_collection import DataCollector
from RedStakeGUI.models.job_number_storage import JobNumberStorage


class FileEntryModel:
    INFO_LABEL_CODES = {
        1: "Please enter a County.",
        2: "Please enter a Parcel ID number.",
        3: "Please enter a Parcel ID number and a county.",
        4: "Error: Parcel ID number {parcel_id} not found in {county}.",
        5: "Retrieving data for Parcel ID number: {parcel_id}...",
        6: "Data retrieved for Parcel ID number: {parcel_id}.",
        7: "User Inputs Cleared.",
        8: "Data unavailable for County: {county}.",
        9: "New Job Number {job_number} generated.",
        10: "Updating job number {job_number}...",
        11: "Job number {job_number} updated.",
        12: "Creating new job number {job_number}...",
        13: "Error creating new job number {job_number}.",
    }

    GUI_TO_PARCEL_KEY_MAP = {
        "Address": "PRIMARY_ADDRESS",
        "Zip Code": "PROP_ZIP",
        "Plat": "SUBDIVISION",
    }

    def __init__(self, inputs: dict, info_label: ttk.Label):
        self.inputs = inputs
        self.info_label = info_label
        self.access_db = ACCESS_DATABASE
        self.job_number_storage = JobNumberStorage(self.access_db.cursor)

    def submit_job_data(self) -> None:
        job_number = self.inputs["Job Number"].get()

        county = self.inputs["County"].get()
        parcel_id = self.inputs["Parcel ID"].get()
        if not county or not parcel_id:
            return self.update_info_label(3)

        parcel_data = DataCollector(parcel_id, county).parcel_data
        print(parcel_data)

        existing_job_table = Table("Existing Jobs", Table.EXISTING_JOBS_SCHEMA)
        active_job_table = Table("Active Jobs", Table.ACTIVE_JOBS_SCHEMA)

        job_data = {
            "Job Number": job_number,
            "County": county,
            "Address Number": parcel_data["PROP_HN"],
            "Street Name": parcel_data["POSTAL_STREET"],
            "Parcel ID": parcel_id,
            "subdivision": parcel_data["SUBDIVISION"],
            "Lot": parcel_data["LOT"],
            "block": parcel_data["BLOCK"],
            "Plat Book": parcel_data["PLAT_BOOK"],
            "Plat Page": parcel_data["PLAT_PAGE"],
            "Legal Description": parcel_data["LEGAL_DESC"],
            "Entry By": self.inputs["Entry By"].get(),
            "Additional Information": self.inputs[
                "Additional Information"
            ].get(),
            "Customer Contact Information": self.inputs[
                "Contact Information"
            ].get(),
            "Order Date": self.inputs["Job Date"].entry.get(),
            "Job Date": self.inputs["Job Date"].entry.get(),
            "Address": parcel_data["PRIMARY_ADDRESS"],
            "Zip Code": parcel_data["PROP_ZIP"],
            "Requested Services": self.inputs["Requested Services"].get(),
            "Fieldwork Status": self.inputs["Fieldwork Date"].entry.get(),
            "Inhouse Status": self.inputs["Inhouse Date"].entry.get(),
        }
        for dictionary in [
            existing_job_table.columns,
            active_job_table.columns,
        ]:
            for key in dictionary.keys():
                if key in job_data.keys():
                    dictionary[key] = job_data[key]

        if job_number in self.job_number_storage.existing_job_numbers:
            self.update_info_label(10, job_number=job_number)
            try:
                self.access_db.run_query(existing_job_table, "UPDATE")
                self.access_db.run_query(active_job_table, "UPDATE")
                self.update_info_label(11, job_number=job_number)
            except Exception as e:
                logging.error(e)
                self.update_info_label(13, job_number=job_number)

        else:
            self.update_info_label(12, job_number=job_number)

    def generate_fn(self) -> None:
        """Generates a new job number for the user. The job number is
        generated by taking the current year and adding a number to the
        end of it. The number is the next unused job number in the
        database."""
        current_year = self.job_number_storage.year

        existing_current_year_jobs = self.access_db.connection.execute(
            f"SELECT [Job Number] FROM [Existing Jobs] WHERE [Job Number]\
    LIKE '{current_year}%'"
        )
        self.job_number_storage.add_current_year_job_numbers(
            existing_current_year_jobs
        )
        unused_job_number = self.job_number_storage.unused_job_number

        self.inputs["Job Number"].delete(0, "end")
        self.inputs["Job Number"].insert(0, unused_job_number)
        self.update_info_label(9, job_number=unused_job_number)

    def get_unused_job_number(self) -> str:
        """Returns the next unused job number in the database.

        Returns:
            str: The next unused job number in the database.
        """
        num_previous_months = 0
        while num_previous_months < 12:
            prefix = self.get_job_number_prefix(num_previous_months)
            job_numbers = [
                number
                for number in self.get_current_year_job_numbers()
                if number.startswith(prefix)
            ]
            if len(job_numbers) == 0:
                num_previous_months += 1
            else:
                highest_existing_fn = max(job_numbers)
                last_four_digits = str(int(highest_existing_fn[4:8]) + 1).zfill(
                    4
                )
                new_fn = self.get_job_number_prefix() + last_four_digits
                break
        else:
            new_fn = self.get_job_number_prefix() + "0100"

        return new_fn

    def gather_job_data(self) -> None:
        pass

    def clear_inputs(self) -> None:
        """Clears all the input fields."""
        for input_field in self.inputs.values():
            if isinstance(input_field, ttk.Entry):
                input_field.delete(0, "end")
            elif isinstance(input_field, ttk.DateEntry):
                input_field.entry.delete(0, "end")
        self.update_info_label(7)

    def update_info_label(self, code: int, **kwargs) -> None:
        """Updates the info label with the text from the
        INFO_LABEL_CODES dictionary.

        Args:
            code (int): The code for the text to be displayed in the
                info label.
            **kwargs: The format keyword arguments for the text to be
                displayed in the info label.

        """
        text = self.INFO_LABEL_CODES[code].format(**kwargs)
        self.info_label.config(text=text)
